import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { HierarchyNode } from '../../../interfaces/hierarchy';
import { hierarchyMockData } from '../../../mockData/hierarchy.mock';
import { autoSplitMetrics } from '../../utils/hierarchyUtils';

interface HierarchyState {
  tree: HierarchyNode[];
}

const initialState: HierarchyState = {
  tree: hierarchyMockData
};

// ðŸ” Find parent of a node
const findParent = (
  nodes: HierarchyNode[],
  childId: string
): HierarchyNode | null => {
  for (const node of nodes) {
    if (node.children?.some(c => c.id === childId)) {
      return node;
    }
    if (node.children) {
      const found = findParent(node.children, childId);
      if (found) return found;
    }
  }
  return null;
};

// ðŸ” Normalize metrics
const normalizeMetrics = (nodes: HierarchyNode[]) => {
  nodes.forEach(node => {
    if (node.level === 'TOPIC' && node.children?.length) {
      node.children = autoSplitMetrics(node.children);
    }
    if (node.children) normalizeMetrics(node.children);
  });
};

normalizeMetrics(initialState.tree);

const hierarchySlice = createSlice({
  name: 'hierarchy',
  initialState,
  reducers: {
    updateWeightage(
      state,
      action: PayloadAction<{ id: string; value: number }>
    ) {
      const parent = findParent(state.tree, action.payload.id);

      if (parent?.children) {
        const siblingsSum = parent.children.reduce(
          (sum, node) =>
            node.id === action.payload.id ? sum : sum + node.weightage,
          0
        );

        if (siblingsSum + action.payload.value > 100) {
          return; // âŒ reject
        }
      }

      const updateNode = (nodes: HierarchyNode[]) => {
        for (const node of nodes) {
          if (node.id === action.payload.id) {
            node.weightage = action.payload.value;
            return true;
          }
          if (node.children && updateNode(node.children)) return true;
        }
        return false;
      };

      updateNode(state.tree);
    },

    deleteNode(state, action: PayloadAction<string>) {
      const removeNode = (nodes: HierarchyNode[]): HierarchyNode[] =>
        nodes
          .filter(n => n.id !== action.payload)
          .map(n => ({
            ...n,
            children: n.children ? removeNode(n.children) : []
          }));

      state.tree = removeNode(state.tree);
    }
  }
});

export const { updateWeightage, deleteNode } = hierarchySlice.actions;
export default hierarchySlice.reducer;
